\section{Question 3: Image Upsampling and Downsampling}

This task focuses on implementing image resizing operations on an embedded system. Both upsampling and downsampling are performed using non-integer scale factors while operating under strict constraints on memory usage and arithmetic precision.

\subsection{Problem Description}

The objective is to resize images captured by the ESP32-CAM using two operations:
\begin{itemize}
    \item \textbf{Upsampling}: Increasing image size by a factor of 1.5
    \item \textbf{Downsampling}: Reducing image size by a factor of 2/3
\end{itemize}

All computations must use integer arithmetic only, as floating-point operations are not suitable for the target platform.

\subsection{Method}

Nearest-neighbor interpolation is selected due to its simplicity, low computational cost, and suitability for embedded systems. Non-integer scaling is implemented using rational scale factors of the form:
\[
\text{scale} = \frac{\text{scale\_num}}{\text{scale\_den}}
\]

For upsampling (1.5×), the scale factors are defined as:
\begin{itemize}
    \item \texttt{scale\_num = 3}
    \item \texttt{scale\_den = 2}
\end{itemize}

For downsampling (2/3×), the scale factors are:
\begin{itemize}
    \item \texttt{scale\_num = 2}
    \item \texttt{scale\_den = 3}
\end{itemize}

Inverse mapping is used to determine the source pixel corresponding to each output pixel:
\[
\text{src\_x} = \frac{\text{out\_x} \times \text{scale\_den}}{\text{scale\_num}}
\]

This approach ensures that all source indices remain valid and avoids gaps or undefined pixels in the output image.

Note: The Python implementation uses more extreme scale factors (2.5× for upsampling and 2/5 for downsampling) for demonstration purposes to make the differences more visible. The ESP32 implementation uses the original scale factors (1.5× and 2/3) as specified in the requirements.

\subsection{Python Implementation on PC}

The resizing algorithm is first implemented and tested in Python. The complete Python implementation is shown in Appendix~\ref{appendix:q3:python}. The code closely mirrors the embedded implementation and uses only integer arithmetic to ensure direct portability.

The main function, \texttt{resize\_nearest\_neighbor()}, performs the following steps:
\begin{itemize}
    \item Computes the output image size using integer arithmetic
    \item Applies inverse mapping to determine source pixel indices
    \item Ensures all coordinates remain within valid bounds
    \item Copies RGB pixel values using nearest-neighbor selection
\end{itemize}

The Python implementation works directly with RGB color images, matching the ESP32 implementation which processes RGB565 color images.

Using the same arithmetic and logic as the ESP32 implementation allows validation of correctness before deployment.

For demonstration purposes, the Python implementation uses more extreme scale factors (2.5× for upsampling and 2/5 for downsampling) to make the differences more visible. The ESP32 implementation uses the original scale factors (1.5× and 2/3) as specified in the requirements.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/q3_comparison.png}
    \caption{Python test results showing original image (160×120), upsampled (400×300 at 2.5×), and downsampled (64×48 at 2/5) versions. The Python implementation uses more extreme scale factors for demonstration; the ESP32 implementation uses 1.5× and 2/3 as specified.}
    \label{fig:q3_python}
\end{figure}

\subsection{ESP32-CAM Implementation and Python Connector Script}

The resizing algorithm is ported to the ESP32-CAM and implemented in C/C++. The complete ESP32 implementation is shown in Appendix~\ref{appendix:q3:esp32}. The system operates on RGB565 images (16 bits per pixel) and applies nearest-neighbor interpolation using integer arithmetic.

Key implementation features include:
\begin{itemize}
    \item Capture of 160×120 RGB565 images
    \item Integer-only resizing using inverse mapping
    \item JPEG encoding to reduce transmission size
    \item Serial transmission of images to a PC
\end{itemize}

The function \texttt{resize\_nearest()} performs resizing directly on RGB565 pixel data by copying source pixels to the appropriate output locations.

\begin{lstlisting}[style=cstyle, caption=Inverse mapping for nearest-neighbor resize (ESP32)]
int src_y = (y * SCALE_DEN) / SCALE_NUM;
int src_x = (x * SCALE_DEN) / SCALE_NUM;

if (src_y >= IN_H) src_y = IN_H - 1;
if (src_x >= IN_W) src_x = IN_W - 1;

resized[y * OUT_W + x] = in_rgb565[src_y * IN_W + src_x];
\end{lstlisting}

A compile-time setting (\texttt{IMAGE\_MODE}) controls the resizing mode:
\begin{itemize}
    \item \texttt{IMAGE\_MODE = 0}: Original image (160×120, no resizing)
    \item \texttt{IMAGE\_MODE = 1}: Upsampling to 240×180 (1.5×)
    \item \texttt{IMAGE\_MODE = 2}: Downsampling to 106×80 (2/3×)
\end{itemize}

The Python receiver script (see Appendix~\ref{appendix:q3:receiver}) receives the transmitted JPEG images and saves them to disk for visualization and analysis.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/q3_original.jpg}
    \caption{Original image from ESP32-CAM: 160×120 pixels (no resizing)}
    \label{fig:q3_original}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/q3_upsampled.jpg}
    \caption{Upsampling result: 160×120 image resized to 240×180 (1.5×)}
    \label{fig:q3_upsample}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/q3_downsampled.jpg}
    \caption{Downsampling result: 160×120 image resized to 106×80 (2/3×)}
    \label{fig:q3_downsample}
\end{figure}

\subsection{Results and Evaluation}

Both upsampling and downsampling operations function correctly using non-integer scale factors. Nearest-neighbor interpolation provides sufficient image quality while maintaining low computational complexity.

Key observations include:
\begin{itemize}
    \item Integer arithmetic correctly supports non-integer scaling ratios
    \item RGB565 color integrity is preserved after resizing
    \item JPEG encoding reduces transmission size effectively
    \item Performance is sufficient for near real-time operation
    \item Embedded results closely match Python reference outputs
\end{itemize}

