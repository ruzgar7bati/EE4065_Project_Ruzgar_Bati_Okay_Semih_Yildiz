\section{Question 3: Complete Code Listings}
\label{appendix:q3}

\subsection{Python Implementation}
\label{appendix:q3:python}

\begin{lstlisting}[style=pythonstyle, caption=Python Implementation for Resizing (\texttt{python/q3.py})]
from PIL import Image
import matplotlib.pyplot as plt
from pathlib import Path

# ===== Configuration =====
# Input image settings
INPUT_IMAGE_PATH = "question1_images/reference_taken_from_phone.jpg"
TARGET_SIZE = (160, 120)  # Resize input to this size before processing

# Increased from 1.5x to 2.5x for upsampling and 2/3 to 2/5 for downsampling
# to show more difference. Will not keep this for ESP32 implementation.
# Resizing scale factors
UPSAMPLE_SCALE_NUM = 5  # For 2.5x upsampling: scale = 5/2
UPSAMPLE_SCALE_DEN = 2
DOWNSAMPLE_SCALE_NUM = 2  # For 2/5 downsampling: scale = 2/5
DOWNSAMPLE_SCALE_DEN = 5

# Output settings
OUTPUT_IMAGE_PATH = "question1_images/q3_comparison.png"
FIGURE_SIZE = (12, 4)  # Figure size in inches (width, height)
FIGURE_DPI = 150  # Resolution for saved figure

# ===== End Configuration =====


def resize_nearest_neighbor(image, scale_num, scale_den):
    """
    ESP32-friendly nearest neighbor resize using integer arithmetic.

    scale = scale_num / scale_den
    Works with RGB images (3 channels).
    """

    input_h = image.height
    input_w = image.width
    pixels = image.load()

    # Compute output dimensions using integer math
    output_h = (input_h * scale_num) // scale_den
    output_w = (input_w * scale_num) // scale_den

    # Create output image
    output = Image.new('RGB', (output_w, output_h))
    output_pixels = output.load()

    # Inverse mapping (nearest neighbor)
    for y in range(output_h):
        for x in range(output_w):
            src_y = (y * scale_den) // scale_num
            src_x = (x * scale_den) // scale_num

            # Clamp to bounds
            if src_y >= input_h:
                src_y = input_h - 1
            if src_x >= input_w:
                src_x = input_w - 1

            # Copy RGB pixel
            output_pixels[x, y] = pixels[src_x, src_y]

    return output


def visualize(original, upsampled, downsampled, save_path=None, figsize=(12, 4), dpi=150):
    """
    Visualization for PC validation only.
    Not part of embedded logic.
    """

    # Get dimensions for each image
    orig_w, orig_h = original.size
    up_w, up_h = upsampled.size
    down_w, down_h = downsampled.size

    plt.figure(figsize=figsize)

    plt.subplot(1, 3, 1)
    plt.title(f"Original\n{orig_w}×{orig_h} pixels")
    plt.imshow(original)
    plt.axis("off")

    upscale = UPSAMPLE_SCALE_NUM / UPSAMPLE_SCALE_DEN
    downscale = DOWNSAMPLE_SCALE_NUM / DOWNSAMPLE_SCALE_DEN
    
    plt.subplot(1, 3, 2)
    plt.title(f"Upsampled ({upscale}x)\n{up_w}×{up_h} pixels")
    plt.imshow(upsampled)
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.title(f"Downsampled ({downscale})\n{down_w}×{down_h} pixels")
    plt.imshow(downsampled)
    plt.axis("off")

    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=dpi, bbox_inches='tight')
        print(f"Saved comparison image to: {save_path}")
        print(f"  Original: {orig_w}×{orig_h} pixels")
        print(f"  Upsampled: {up_w}×{up_h} pixels")
        print(f"  Downsampled: {down_w}×{down_h} pixels")
    else:
        plt.show()


def main():
    # Load image relative to this script's folder
    base_dir = Path(__file__).resolve().parent
    img_path = base_dir / INPUT_IMAGE_PATH
    
    print(f"Loading image from: {img_path}")
    image = Image.open(img_path).convert("RGB")
    
    # Resize to target size (similar to ESP32 resolution)
    image = image.resize(TARGET_SIZE, Image.BILINEAR)
    print(f"Resized to: {TARGET_SIZE}")
    
    # Upsample
    upscale = UPSAMPLE_SCALE_NUM / UPSAMPLE_SCALE_DEN
    print(f"Upsampling ({upscale}x)...")
    upsampled = resize_nearest_neighbor(image, scale_num=UPSAMPLE_SCALE_NUM, scale_den=UPSAMPLE_SCALE_DEN)
    print(f"Upsampled size: {upsampled.size[0]}x{upsampled.size[1]}")
    
    # Downsample
    downscale = DOWNSAMPLE_SCALE_NUM / DOWNSAMPLE_SCALE_DEN
    print(f"Downsampling ({downscale})...")
    downsampled = resize_nearest_neighbor(image, scale_num=DOWNSAMPLE_SCALE_NUM, scale_den=DOWNSAMPLE_SCALE_DEN)
    print(f"Downsampled size: {downsampled.size[0]}x{downsampled.size[1]}")
    
    # Save comparison image
    output_path = base_dir / OUTPUT_IMAGE_PATH
    visualize(image, upsampled, downsampled, save_path=str(output_path), figsize=FIGURE_SIZE, dpi=FIGURE_DPI)


if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{ESP32-CAM Implementation}
\label{appendix:q3:esp32}

\begin{lstlisting}[style=cstyle, caption=ESP32 CAM Resizing Code (\texttt{esp32\_cam\_link/esp32\_cam\_q3/esp32\_cam\_q3.ino})]
#include "esp_camera.h"
#include "img_converters.h"

// ===== AI Thinker ESP32-CAM pin map =====
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

#define FLASH_GPIO 4

// Input resolution
#define IN_W 160
#define IN_H 120

// ===== SCALE FACTOR CONFIGURATION =====
// Set to 0 for ORIGINAL (1/1), 1 for UPSAMPLING (1.5x = 3/2), or 2 for DOWNSAMPLING (2/3)
#define IMAGE_MODE 0  // 0=Original, 1=Upsample, 2=Downsample

#if IMAGE_MODE == 0
  // Original: 1/1 → scale_num=1, scale_den=1
  #define SCALE_NUM 1
  #define SCALE_DEN 1
#elif IMAGE_MODE == 1
  // Upsampling: 1.5x → scale_num=3, scale_den=2
  #define SCALE_NUM 3
  #define SCALE_DEN 2
#else
  // Downsampling: 2/3 → scale_num=2, scale_den=3
  #define SCALE_NUM 2
  #define SCALE_DEN 3
#endif

#define OUT_W ((IN_W * SCALE_NUM) / SCALE_DEN)
#define OUT_H ((IN_H * SCALE_NUM) / SCALE_DEN)

static uint16_t resized[OUT_W * OUT_H];
static uint8_t *jpeg_buf = NULL;
static size_t jpeg_len = 0;

void setup() {
  Serial.begin(921600);
  delay(2000);

  #if IMAGE_MODE == 0
    Serial.println("ESP32 CAM: ORIGINAL mode (1/1 - no resizing)");
    Serial.printf("Output: %dx%d\n", OUT_W, OUT_H);
  #elif IMAGE_MODE == 1
    Serial.println("ESP32 CAM: UPSAMPLING mode (1.5x = 3/2)");
    Serial.printf("Input: %dx%d -> Output: %dx%d\n", IN_W, IN_H, OUT_W, OUT_H);
  #else
    Serial.println("ESP32 CAM: DOWNSAMPLING mode (2/3)");
    Serial.printf("Input: %dx%d -> Output: %dx%d\n", IN_W, IN_H, OUT_W, OUT_H);
  #endif

  pinMode(FLASH_GPIO, OUTPUT);
  digitalWrite(FLASH_GPIO, LOW);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;

  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_RGB565;
  config.frame_size   = FRAMESIZE_QQVGA;  // 160x120
  config.fb_count     = 1;

  esp_camera_init(&config);
}

// Nearest neighbor resize (RGB565 color)
// Works for both upsampling and downsampling using integer arithmetic
// Uses inverse mapping: for each output pixel, find nearest input pixel
void resize_nearest(uint8_t *in) {
  uint16_t *in_rgb565 = (uint16_t *)in;
  for (int y = 0; y < OUT_H; y++) {
    for (int x = 0; x < OUT_W; x++) {
      // Inverse mapping: calculate source pixel position
      int src_y = (y * SCALE_DEN) / SCALE_NUM;
      int src_x = (x * SCALE_DEN) / SCALE_NUM;

      // Clamp to bounds
      if (src_y >= IN_H) src_y = IN_H - 1;
      if (src_x >= IN_W) src_x = IN_W - 1;

      // Copy pixel from source to destination
      resized[y * OUT_W + x] =
        in_rgb565[src_y * IN_W + src_x];
    }
  }
}

void loop() {
  digitalWrite(FLASH_GPIO, HIGH);
  delay(20);

  camera_fb_t *fb = esp_camera_fb_get();
  digitalWrite(FLASH_GPIO, LOW);
  if (!fb) return;

  #if IMAGE_MODE == 0
    // Original mode: copy directly without resizing
    uint16_t *in_rgb565 = (uint16_t *)fb->buf;
    for (int i = 0; i < OUT_W * OUT_H; i++) {
      resized[i] = in_rgb565[i];
    }
  #else
    // Upsampling or downsampling: use resize function
    resize_nearest(fb->buf);
  #endif

  // Encode resized image as JPEG
  // Debug: print actual dimensions being encoded
  Serial.printf("Encoding image: %dx%d pixels\n", OUT_W, OUT_H);
  
  bool ok = fmt2jpg(
      (uint8_t *)resized,
      OUT_W * OUT_H * 2,
      OUT_W,
      OUT_H,
      PIXFORMAT_RGB565,
      80,
      &jpeg_buf,
      &jpeg_len
  );

  if (ok) {
    Serial.printf("JPEG encoded: %d bytes\n", jpeg_len);
    uint8_t sync[2] = {0xAA, 0x55};
    Serial.write(sync, 2);
    Serial.write((uint8_t *)&jpeg_len, 4);
    Serial.write(jpeg_buf, jpeg_len);
    free(jpeg_buf);
  } else {
    Serial.println("JPEG encoding failed!");
  }

  esp_camera_fb_return(fb);
  delay(1000);
}
\end{lstlisting}

\subsection{Python Connector Script}
\label{appendix:q3:receiver}

\begin{lstlisting}[style=pythonstyle, caption=Python Receiver Script (\texttt{esp32\_cam\_link/esp32\_cam\_q3/receive.py})]
import serial
import struct

PORT = "COM4"
BAUD = 921600

# Simple receiver for ESP32 CAM resized images (upsampled or downsampled)
# Just receives JPEG images and saves them

ser = serial.Serial(
    PORT,
    BAUD,
    timeout=5,
    dsrdtr=False,
    rtscts=False
)

ser.setDTR(False)
ser.setRTS(False)

img_count = 0
print("Waiting for frames from ESP32 CAM...")

while True:
    # Find sync word (0xAA 0x55)
    if ser.read(1) != b'\xAA':
        continue
    if ser.read(1) != b'\x55':
        continue

    # Read image size (4 bytes, little-endian)
    size_bytes = ser.read(4)
    if len(size_bytes) != 4:
        continue

    size = struct.unpack("<I", size_bytes)[0]

    # Read image data
    data = ser.read(size)
    if len(data) != size:
        print("Incomplete frame")
        continue

    img_count += 1
    filename = f"resized.jpg"
    with open(filename, "wb") as f:
        f.write(data)

    print(f"Saved {filename} ({size} bytes) - Frame #{img_count}")
\end{lstlisting}
