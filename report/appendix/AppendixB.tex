\section{Question 2: Relevant Code Snippets}
\label{appendix:q2}

Due to the large size of the YOLO implementation, only key code sections showing the logic flow are included here. The complete code is available in the \texttt{python/question2\_new} directory.

\subsection{Dataset Preparation Key Functions}
\label{appendix:q2:dataset}

\begin{lstlisting}[style=pythonstyle, caption=Key Functions from Dataset Preparation Script]
def get_class_id_from_filename(filename):
    """Extract class ID from filename: 0_1.png → class 0, 4_5.png → class 1, 7_6.png → class 2"""
    if filename.startswith('0_'):
        return 0  # Class 0 = digit "0"
    elif filename.startswith('4_'):
        return 1  # Class 1 = digit "4"
    elif filename.startswith('7_'):
        return 2  # Class 2 = digit "7"
    return None

def get_image_number(filename):
    """Extract image number from filename: 0_1.png → 1, 4_6.png → 6"""
    parts = filename.split('_')
    if len(parts) >= 2:
        try:
            return int(parts[1].split('.')[0])
        except:
            return None
    return None

def detect_digit_region(image):
    """Detect bounding box of digit in image using contour detection"""
    _, binary = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largest_contour)
        
        # Add 10% padding
        h_img, w_img = image.shape
        padding_x = int(w * 0.1)
        padding_y = int(h * 0.1)
        x = max(0, x - padding_x)
        y = max(0, y - padding_y)
        w = min(w_img - x, w + 2 * padding_x)
        h = min(h_img - y, h + 2 * padding_y)
        return x, y, w, h
    
    # Fallback: centered box covering 80% of image
    h_img, w_img = image.shape
    margin = int(w_img * 0.1)
    return margin, margin, w_img - 2*margin, h_img - 2*margin

def create_label_file(image_path, label_dir, image):
    """Create YOLO format label file: class_id center_x center_y width height (all normalized)"""
    filename = os.path.basename(image_path)
    label_path = os.path.join(label_dir, os.path.splitext(filename)[0] + '.txt')
    
    class_id = get_class_id_from_filename(filename)
    if class_id is None:
        return
    
    x, y, w, h = detect_digit_region(image)
    img_h, img_w = image.shape
    
    # Convert to YOLO format (normalized)
    center_x = max(0, min(1, (x + w / 2) / img_w))
    center_y = max(0, min(1, (y + h / 2) / img_h))
    norm_width = max(0, min(1, w / img_w))
    norm_height = max(0, min(1, h / img_h))
    
    with open(label_path, 'w') as f:
        f.write(f"{class_id} {center_x:.6f} {center_y:.6f} {norm_width:.6f} {norm_height:.6f}\n")
\end{lstlisting}

\subsection{Training Script Configuration and Logic}
\label{appendix:q2:training}

\begin{lstlisting}[style=pythonstyle, caption=Training Configuration and Main Training Function]
from ultralytics import YOLO
import pandas as pd
from pathlib import Path
import time

# Configuration
HYPERPARAMETER_EXPERIMENTS = [
    {"lr0": 0.001, "batch": 2, "name": "lr0.001_batch2"},
    {"lr0": 0.001, "batch": 4, "name": "lr0.001_batch4"},
    {"lr0": 0.001, "batch": 8, "name": "lr0.001_batch8"},
    {"lr0": 0.01, "batch": 2, "name": "lr0.01_batch2"},
    {"lr0": 0.01, "batch": 4, "name": "lr0.01_batch4"},
    {"lr0": 0.01, "batch": 8, "name": "lr0.01_batch8"},
]

def run_experiment(exp_config, exp_id):
    model = YOLO("yolov8n.pt")
    project_name = f"exp_{exp_id + 1}_{exp_config['name']}"

    # Train model
    results = model.train(
        data="data.yaml",
        epochs=50,
        imgsz=320,
        batch=exp_config["batch"],
        lr0=exp_config["lr0"],
        device="cpu",
        project=str(RESULTS_DIR),
        name=project_name,
        save=True,
        plots=True,
    )

    # Extract metrics from training results
    if hasattr(results, 'results_dict'):
        metrics = results.results_dict
        map50 = float(metrics.get('metrics/mAP50(B)', 0.0))
        precision = float(metrics.get('metrics/precision(B)', 0.0))
        recall = float(metrics.get('metrics/recall(B)', 0.0))
    elif hasattr(results, 'metrics') and hasattr(results.metrics, 'box'):
        m = results.metrics.box
        map50 = float(m.map50)
        precision = float(m.mp)
        recall = float(m.mr)
    else:
        # Fallback: run validation explicitly
        val_results = model.val(data="data.yaml", imgsz=320)
        m = val_results.metrics.box
        map50 = float(m.map50)
        precision = float(m.mp)
        recall = float(m.mr)

    return {
        "name": exp_config["name"],
        "learning_rate": exp_config["lr0"],
        "batch_size": exp_config["batch"],
        "mAP50": map50,
        "precision": precision,
        "recall": recall,
        "model_path": str(best_model_path),
    }
\end{lstlisting}

\subsection{Model Evaluation Logic}
\label{appendix:q2:evaluation}

\begin{lstlisting}[style=pythonstyle, caption=Test Script Main Evaluation Function]
from ultralytics import YOLO
import pandas as pd
from pathlib import Path

def extract_metrics(results):
    """Extract metrics from validation results"""
    if hasattr(results, 'metrics') and hasattr(results.metrics, 'box'):
        m = results.metrics.box
        return (
            float(m.map50),
            float(m.map),
            float(m.mp),
            float(m.mr),
        )
    return (0.0, 0.0, 0.0, 0.0)

def test_model(model_path):
    model = YOLO(model_path)

    # Create temporary data.yaml pointing val to test set
    temp_yaml = "data_test.yaml"
    with open("data.yaml", "r") as f:
        lines = f.readlines()

    with open(temp_yaml, "w") as f:
        for line in lines:
            if line.strip().startswith("val:"):
                f.write("val: images/test\n")
            else:
                f.write(line)

    try:
        results = model.val(
            data=temp_yaml,
            conf=0.4,
            verbose=True,
        )

        map50, map5095, precision, recall = extract_metrics(results)

        return {
            "mAP50": map50,
            "mAP50_95": map5095,
            "precision": precision,
            "recall": recall,
        }
    finally:
        if os.path.exists(temp_yaml):
            os.remove(temp_yaml)
\end{lstlisting}

\subsection{Note on Code Size}

The complete YOLO implementation includes:
\begin{itemize}
    \item Dataset preparation script: 225 lines
    \item Training script: 201 lines
    \item Test script: 199 lines
    \item Inference script: 131 lines
    \item Data configuration file
    \item Multiple hyperparameter experiment results
\end{itemize}

The full codebase is available in the project repository at \texttt{python/question2\_new/}.
